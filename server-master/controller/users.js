
// // import { json } from 'express';
// // import {
// //     getUsersPaged,
// //     addUser,
// //     deleteUser,
// //     updateUser,
// //     getUserByEmail,
// //     verifyPassword
// // } from '../service/userData.js';
// // import jwt from 'jsonwebtoken';
// // import bcrypt from 'bcrypt';

// // export class user {

// //     // üì• req.query: { page?: number, limit?: number }
// //     // üì§ res: JSON array of users, each: { id, userName, email, userType }
// //     getAllUsers = async (req, res) => {
// //         try {
// //             const page = parseInt(req.query.page) || 1;
// //             const limit = parseInt(req.query.limit) || 12;

// //             const users = await getUsersPaged(page, limit);
// //             res.status(200).json(users); // üü© 200 OK
// //         } catch (error) {
// //             res.status(500).json({ message: "Failed to retrieve users" }); // ‚ùå 500 Internal Server Error
// //         }
// //     };



// //     login = async (req, res) => {
// //         console.log("in login ");
// //         console.log(req.body);

// //         const { email, password } = req.body;

// //         if (!email || !password) {
// //             return res.status(400).json('Missing email or password');
// //         }

// //         try {
// //             const user = await getUserByEmail(email);
// //             if (!user) {
// //                 console.log('User not found');
// //                 return res.status(404).json('not found');
// //             }



// //             console.log('password:', `"${password}"`);
// //             console.log('hash:', `"${user.passwordHash}"`);
// //             const isMatch = await bcrypt.compare(password, user.passwordHash);
// //             console.log('bcrypt result:', isMatch);

// //             if (!isMatch) {
// //                 console.log('Incorrect password');
// //                 return res.status(401).json('Unauthorized');
// //             }

// //            const { passwordHash, ...userWithoutPassword } = user;

// //             const token = jwt.sign(
// //                 {
// //                     id: user.id,
// //                     email: user.email,
// //                     userName: user.userName,
// //                     userType: user.userType
// //                 },
// //                 process.env.JWT_SECRET,
// //                 { expiresIn: '2h' }
// //             );

// //             return res.status(200).json({ user: userWithoutPassword, token });

// //         } catch (error) {
// //             console.error('Login error:', error.message);
// //             return res.status(500).json( error.message);
// //         }
// //     };

// //     // üì• req.params: { id: string }
// //     // üì• req.body: {
// //     //   userName?: string,
// //     //   email?: string,
// //     //   userType?: string,
// //     //   password?: string,
// //     //   lastPassword?: string
// //     // }
// //     // üì§ res: string 'updated successfully'
// //     update = async (req, res) => {
// //         try {
// //             const id = req.params.id;
// //             const { password, lastPassword } = req.body;

// //             if (password || lastPassword) {
// //                 if (!password || !lastPassword) {
// //                     return res.status(400).json({ message: 'Bad Request' }); // ‚ùå 400 Bad Request
// //                 }

// //                 if (!await verifyPassword(id, lastPassword)) {
// //                     return res.status(401).json({ message: 'Unauthorized' }); // ‚ùå 401 Unauthorized
// //                 }
// //             }

// //             await updateUser(id, req.body);
// //             res.status(200).json('updated successfully'); // üü© 200 OK

// //         } catch (error) {
// //             console.error('Update error:', error.message);
// //             res.status(422).json({ message: 'Unprocessable Entity' }); // ‚ùå 422 Unprocessable Entity
// //         }
// //     };

// //     // üì• req.body: {
// //     //   userName: string,
// //     //   email: string,
// //     //   userType: string,
// //     //   password: string
// //     // }
// //     // üì§ res: { id: number, userName, email, userType }
// //     add = async (req, res) => {
// //         try {
// //             let newUser = req.body;

// //             if (!newUser || !isValidEmail(newUser.email)) {
// //                 return res.status(400).send('Bad Request'); // ‚ùå 400 Bad Request
// //             }

// //             if (!newUser.password) {
// //                 return res.status(400).send('Bad Request'); // ‚ùå 400 Bad Request
// //             }

// //             const passwordHash = await bcrypt.hash(newUser.password, 10);
// //             const userToSave = { ...newUser, passwordHash };

// //             console.log("is ok");
// //             const userId = await addUser(userToSave);
// //             const createdUser = {
// //                 id: userId,
// //                 userName: newUser.userName,
// //                 email: newUser.email,
// //                 userType: newUser.userType
// //             };

// //             res.status(201).json(createdUser); // üü© 201 Created

// //         } catch (error) {
// //             console.error('Add user error:', error.message);
// //             res.status(500).json('Failed to create user'); // ‚ùå 500 Internal Server Error
// //         }
// //     };

// //     // üì• req.params: { id: string }
// //     // üì§ res: status 204 (no content) or 404 if not found
// //     delete = async (req, res) => {
// //         try {
// //             const userToDelete = req.params.id;
// //             const response = await deleteUser(userToDelete);

// //             if (response) {
// //                 res.status(204).send(); // üü© 204 No Content
// //             } else {
// //                 res.status(404).json("User not found"); // ‚ùå 404 Not Found
// //             }
// //         } catch (error) {
// //             res.status(500).json('Failed to delete user'); // ‚ùå 500 Internal Server Error
// //         }
// //     };
// // }

// // // üì• email: string ‚Üí ◊û◊ó◊ñ◊ô◊®◊î true/false ◊ú◊§◊ô ◊™◊ß◊ô◊†◊ï◊™ ◊ê◊ô◊û◊ô◊ô◊ú
// // function isValidEmail(email) {
// //     const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
// //     return emailRegex.test(email);
// // }
// import { json } from 'express';
// import {
//     getUsersPaged,
//     addUser,
//     deleteUser,
//     updateUser,
//     getUserByEmail,
//     verifyPassword
// } from '../service/userData.js';
// import jwt from 'jsonwebtoken';
// import bcrypt from 'bcrypt';

// export class user {

//     /**
//      * üì• Query: { page?: number, limit?: number }
//      * üì§ Response: JSON array of users, each: { id, userName, email, userType }
//      */
//     getAllUsers = async (req, res) => {
//         try {
//             const page = parseInt(req.query.page) || 1;
//             const limit = parseInt(req.query.limit) || 12;

//             const users = await getUsersPaged(page, limit);
//             res.status(200).json(users); // üü© 200 OK
//         } catch (error) {
//             res.status(500).json({ message: "Failed to retrieve users" }); // ‚ùå 500 Internal Server Error
//         }
//     };

//     /**
//      * üì• Body: { email: string, password: string }
//      * üì§ Response: { user: { id, email, userName, userType }, token: string }
//      */
//     login = async (req, res) => {
//         console.log("in login ");
//         console.log(req.body);

//         const { email, password } = req.body;

//         if (!email || !password) {
//             return res.status(400).json('Missing email or password');
//         }

//         try {
//             const user = await getUserByEmail(email);
//             if (!user) {
//                 console.log('User not found');
//                 return res.status(404).json('not found');
//             }

//             console.log(user);
//             console.log('password:', `"${password}"`);
//             console.log('hash:', `"${user.passwordHash}"`);
//             const isMatch = await bcrypt.compare(password,user.passwordHash);
//             console.log('bcrypt result:', isMatch);

//             if (!isMatch) {
//                 console.log('Incorrect password');
//                 return res.status(401).json('Unauthorized');
//             }

//             const { passwordHash, ...userWithoutPassword } = user;

//             const token = jwt.sign(
//                 {
//                     id: user.id,
//                     email: user.email,
//                     userName: user.userName,
//                     userType: user.userType
//                 },
//                 process.env.JWT_SECRET,
//                 { expiresIn: '2h' }
//             );

//             return res.status(200).json({ user: userWithoutPassword, token });

//         } catch (error) {
//             console.error('Login error:', error.message);
//             return res.status(500).json(error.message);
//         }
//     };

//     /**
//      * üì• Params: { id: string }
//      * üì• Body: {
//      *   userName?: string,
//      *   email?: string,
//      *   userType?: string,
//      *   password?: string,
//      *   lastPassword?: string
//      * }
//      * üì§ Response: string 'updated successfully'
//      */
//     update = async (req, res) => {
//         try {
//             const id = req.params.id;
//             const { password, lastPassword } = req.body;

//             if (password || lastPassword) {
//                 if (!password || !lastPassword) {
//                     return res.status(400).json({ message: 'Bad Request' }); // ‚ùå 400 Bad Request
//                 }

//                 const authorized = await verifyPassword(id, lastPassword);
//                 if (!authorized) {
//                     return res.status(401).json({ message: 'Unauthorized' }); // ‚ùå 401 Unauthorized
//                 }
//             }

//             await updateUser(id, req.body);
//             res.status(200).json('updated successfully'); // üü© 200 OK

//         } catch (error) {
//             console.error('Update error:', error.message);
//             res.status(422).json({ message: 'Unprocessable Entity' }); // ‚ùå 422 Unprocessable Entity
//         }
//     };

//     /**
//      * üì• Body: {
//      *   userName: string,
//      *   email: string,
//      *   password: string
//      * }
//      * üì§ Response: {
//      *   id: number,
//      *   userName: string,
//      *   email: string,
//      *  
//      * }
//      */
//     // add = async (req, res) => {
//     //     try {
//     //         let newUser = req.body;

//     //         if (!newUser || !isValidEmail(newUser.email)) {
//     //             return res.status(400).send('Bad Request'); // ‚ùå 400 Bad Request
//     //         }

//     //         if (!newUser.password) {
//     //             return res.status(400).send('Bad Request'); // ‚ùå 400 Bad Request
//     //         }

//     //         const passwordHash = await bcrypt.hash(newUser.password, 10);
//     //          console.log(passwordHash);
//     //         const userToSave = {
//     //             ...newUser,
//     //            passwordHash: passwordHash,
//     //             userType: 2 // üëà ◊ë◊®◊ô◊®◊™ ◊û◊ó◊ì◊ú ◊ß◊ë◊ï◊¢◊î
//     //         };

//     //         console.log("is ok");
//     //         const userId = await addUser(userToSave);
//     //         const createdUser = {
//     //             id: userId,
//     //             userName: newUser.userName,
//     //             email: newUser.email,
//     //         };

//     //         res.status(201).json(createdUser); // üü© 201 Created

//     //     } catch (error) {
//     //         console.error('Add user error:', error.message);
//     //         res.status(400).json(error.message); // ‚ùå 500 Internal Server Error
//     //     }
//     // };
// add = async (req, res) => {
//   try {
//     const newUser = req.body;

//     if (!newUser || !isValidEmail(newUser.email)||!newUser.password) {
//       return res.status(400).send('Bad Request');
//     }

   

//     const passwordHash = await bcrypt.hash(newUser.password, 10);
//     const userToSave = {
//       ...newUser,
//       passwordHash,
//       userType: 2 // ◊ë◊®◊ô◊®◊™ ◊û◊ó◊ì◊ú
//     };

//     const user = await addUser(userToSave);

//     // üü¢ ◊©◊ú◊ô◊§◊î ◊û◊ú◊ê◊î ◊©◊ú ◊î◊û◊©◊™◊û◊© ◊ê◊ó◊®◊ô ◊î◊ï◊°◊§◊î
    

//     if (!user) {
//       return res.status(404).json({ message: '◊û◊©◊™◊û◊© ◊ú◊ê ◊†◊û◊¶◊ê ◊ú◊ê◊ó◊® ◊î◊ï◊°◊§◊î' });
//     }

//     // üõ°Ô∏è ◊ô◊¶◊ô◊®◊™ ◊ò◊ï◊ß◊ü
//     const token = jwt.sign(
//       {
//         id: user.id,
//         email: user.email,
//         userName: user.userName,
//         userType: user.userType
//       },
//       process.env.JWT_SECRET,
//       { expiresIn: '2h' }
//     );

//     // ‚úÖ ◊î◊ó◊ñ◊®◊î ◊ú◊§◊ô ◊î◊ì◊®◊ô◊©◊î ◊©◊ú◊ö
//     res.status(201).json({
//       user,
//       token
//     });

//   } catch (error) {
//     console.error('Add user error:', error.message);
//     res.status(400).json({ message: error.message });
//   }
// };

//     /**
//      * üì• Params: { id: string }
//      * üì§ Response: status 204 (No Content) ◊ê◊ï 404 ◊ê◊ù ◊ú◊ê ◊†◊û◊¶◊ê
//      */
//     delete = async (req, res) => {
//         try {
//             const userToDelete = req.params.id;
//             const response = await deleteUser(userToDelete);

//             if (response) {
//                 res.status(204).send(); // üü© 204 No Content
//             } else {
//                 res.status(404).json("User not found"); // ‚ùå 404 Not Found
//             }
//         } catch (error) {
//             res.status(500).json('Failed to delete user'); // ‚ùå 500 Internal Server Error
//         }
//     };
// }

// /**
//  * ◊§◊ï◊†◊ß◊¶◊ô◊ô◊™ ◊¢◊ñ◊®: ◊ë◊ì◊ô◊ß◊™ ◊™◊ß◊ô◊†◊ï◊™ ◊ê◊ô◊û◊ô◊ô◊ú
//  * üì• email: string
//  * üì§ ◊û◊ó◊ñ◊ô◊®◊î true ◊ê◊ù ◊™◊ß◊ô◊ü, ◊ê◊ó◊®◊™ false
//  */
// function isValidEmail(email) {
//     const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
//     return emailRegex.test(email);
// }
import {
  getUsersPaged,
  addUser,
  deleteUser,
  updateUser,
  getUserByEmail,
  verifyPassword
} from '../service/userData.js';
import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt';

/**
 * ◊ë◊ì◊ô◊ß◊™ ◊™◊ß◊ô◊†◊ï◊™ ◊©◊ì◊ï◊™ ◊û◊©◊™◊û◊©
 * @param {Object} data 
 * @param {Object} options 
 * @returns {Object} { isValid, errors }
 */
function validateUserData(data, options = { email: true, password: true, userName: false }) {
  const errors = {};

  if (options.email) {
    const email = data.email || '';
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      errors.email = "◊î◊û◊ô◊ô◊ú ◊ê◊ô◊†◊ï ◊™◊ß◊†◊ô";
    }
  }

  if (options.password) {
    const password = data.password || '';
    if (password.length < 6) {
      errors.password = "◊î◊°◊ô◊°◊û◊î ◊ó◊ô◊ô◊ë◊™ ◊ú◊î◊õ◊ô◊ú ◊ú◊§◊ó◊ï◊™ 6 ◊™◊ï◊ï◊ô◊ù";
    }
  }

  if (options.userName) {
    const userName = data.userName || '';
    if (!/^[\u0590-\u05FF]+$/.test(userName) || userName.length < 2) {
      errors.userName = "◊©◊ù ◊û◊©◊™◊û◊© ◊ó◊ô◊ô◊ë ◊ú◊î◊õ◊ô◊ú ◊ú◊§◊ó◊ï◊™ 2 ◊ê◊ï◊™◊ô◊ï◊™ ◊ë◊¢◊ë◊®◊ô◊™ ◊ë◊ú◊ë◊ì";
    }
  }

  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
}

export class user {

  getAllUsers = async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 12;
      const users = await getUsersPaged(page, limit);
      res.status(200).json(users);
    } catch (error) {
      res.status(500).json({ message: "◊©◊í◊ô◊ê◊î ◊ë◊¢◊™ ◊©◊ú◊ô◊§◊™ ◊î◊û◊©◊™◊û◊©◊ô◊ù" });
    }
  };

  login = async (req, res) => {
    try {
      const { email, password } = req.body;
      const { isValid, errors } = validateUserData({ email, password });

      if (!isValid) {
        return res.status(400).json({ message: "◊©◊ì◊ï◊™ ◊ú◊ê ◊™◊ß◊ô◊†◊ô◊ù", errors });
      }

      const user = await getUserByEmail(email);
      if (!user) return res.status(404).json({ message: '◊û◊©◊™◊û◊© ◊ú◊ê ◊†◊û◊¶◊ê' });

      const isMatch = await bcrypt.compare(password, user.passwordHash);
      if (!isMatch) return res.status(401).json({ message: '◊°◊ô◊°◊û◊î ◊©◊í◊ï◊ô◊î' });

      const { passwordHash, ...userWithoutPassword } = user;
      const token = jwt.sign(userWithoutPassword, process.env.JWT_SECRET, { expiresIn: '2h' });

      res.status(200).json({ user: userWithoutPassword, token });

    } catch (error) {
      console.error('Login error:', error.message);
      res.status(500).json({ message: '◊©◊í◊ô◊ê◊î ◊ë◊©◊®◊™' });
    }
  };

  update = async (req, res) => {
    try {
      const id = req.params.id;
      const { password, lastPassword } = req.body;

      const { isValid, errors } = validateUserData(req.body, {
        email: !!req.body.email,
        password: !!password,
        userName: !!req.body.userName
      });

      if (!isValid) {
        return res.status(400).json({ message: "◊©◊ì◊ï◊™ ◊ú◊ê ◊™◊ß◊ô◊†◊ô◊ù", errors });
      }

      if (password || lastPassword) {
        if (!password || !lastPassword) {
          return res.status(400).json({ message: '◊ó◊ï◊ë◊î ◊ú◊î◊ñ◊ô◊ü ◊í◊ù ◊°◊ô◊°◊û◊î ◊†◊ï◊õ◊ó◊ô◊™ ◊ï◊í◊ù ◊ó◊ì◊©◊î' });
        }

        const authorized = await verifyPassword(id, lastPassword);
        if (!authorized) return res.status(401).json({ message: '◊°◊ô◊°◊û◊î ◊†◊ï◊õ◊ó◊ô◊™ ◊©◊í◊ï◊ô◊î' });
      }

      await updateUser(id, req.body);
      res.status(200).json({ message: '◊î◊û◊©◊™◊û◊© ◊¢◊ï◊ì◊õ◊ü ◊ë◊î◊¶◊ú◊ó◊î' });

    } catch (error) {
      console.error('Update error:', error.message);
      res.status(422).json({ message: '◊©◊í◊ô◊ê◊î ◊ë◊¢◊ô◊ë◊ï◊ì ◊î◊†◊™◊ï◊†◊ô◊ù' });
    }
  };

  add = async (req, res) => {
    try {
      const newUser = req.body;

      const { isValid, errors } = validateUserData(newUser, {
        email: true,
        password: true,
        userName: true
      });

      if (!isValid) {
        return res.status(400).json({ message: "◊©◊ì◊ï◊™ ◊ú◊ê ◊™◊ß◊ô◊†◊ô◊ù", errors });
      }

      const passwordHash = await bcrypt.hash(newUser.password, 10);
      const userToSave = {
        ...newUser,
        passwordHash,
        userType: 2
      };

      const user = await addUser(userToSave);
      if (!user) {
        return res.status(404).json({ message: '◊©◊í◊ô◊ê◊î ◊ë◊©◊û◊ô◊®◊™ ◊î◊û◊©◊™◊û◊©' });
      }

      const token = jwt.sign(
        {
          id: user.id,
          email: user.email,
          userName: user.userName,
          userType: user.userType
        },
        process.env.JWT_SECRET,
        { expiresIn: '2h' }
      );

      res.status(201).json({ user, token });

    } catch (error) {
      console.error('Add user error:', error.message);
      const msg = error.message.includes('◊õ◊ë◊® ◊ß◊ô◊ô◊ù') ? error.message : '◊©◊í◊ô◊ê◊î ◊ë◊¢◊™ ◊ô◊¶◊ô◊®◊™ ◊û◊©◊™◊û◊©';
      res.status(400).json({ message: msg });
    }
  };

  delete = async (req, res) => {
    try {
      const userId = req.params.id;
      const deleted = await deleteUser(userId);
      if (deleted) {
        res.status(204).send();
      } else {
        res.status(404).json({ message: "◊û◊©◊™◊û◊© ◊ú◊ê ◊†◊û◊¶◊ê" });
      }
    } catch (error) {
      res.status(500).json({ message: "◊©◊í◊ô◊ê◊î ◊ë◊û◊ó◊ô◊ß◊™ ◊û◊©◊™◊û◊©" });
    }
  };
}
